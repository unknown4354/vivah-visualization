import puppeteer from 'puppeteer'
import { PDFDocument, rgb, StandardFonts } from 'pdf-lib'
import { prisma } from '@/lib/prisma'

interface ExportImageOptions {
  width?: number
  height?: number
  format?: 'png' | 'jpeg' | 'webp'
  quality?: number
}

interface ShareLinkOptions {
  canEdit?: boolean
  canComment?: boolean
  canExport?: boolean
  password?: string
  expiresIn?: number // hours
}

export class ExportService {
  // Export project to PDF with floor plan, 3D views, and inventory
  async exportToPDF(projectId: string): Promise<Buffer> {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: {
        venue: true,
        user: true,
        items: {
          include: { furnitureItem: true }
        }
      }
    })

    if (!project) throw new Error('Project not found')

    // Create PDF document
    const pdfDoc = await PDFDocument.create()
    const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica)
    const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold)

    // Page 1: Cover Page
    const coverPage = pdfDoc.addPage([612, 792]) // Letter size
    const { height } = coverPage.getSize()

    // Title
    coverPage.drawText(project.name, {
      x: 50,
      y: height - 100,
      size: 32,
      font: helveticaBold,
      color: rgb(0.1, 0.1, 0.1)
    })

    // Subtitle
    coverPage.drawText('Wedding Visualization Project', {
      x: 50,
      y: height - 140,
      size: 14,
      font: helvetica,
      color: rgb(0.4, 0.4, 0.4)
    })

    // Project details
    let yPos = height - 200
    const details = [
      `Created by: ${project.user.name || project.user.email}`,
      `Status: ${project.status}`,
      project.venue ? `Venue: ${project.venue.name}` : null,
      project.eventDate ? `Event Date: ${new Date(project.eventDate).toLocaleDateString()}` : null,
      project.guestCount ? `Guest Count: ${project.guestCount}` : null,
      project.budget ? `Budget: $${project.budget.toLocaleString()}` : null,
      `Total Items: ${project.items.length}`,
      `Last Updated: ${new Date(project.updatedAt).toLocaleDateString()}`
    ].filter(Boolean)

    details.forEach(detail => {
      coverPage.drawText(detail!, {
        x: 50,
        y: yPos,
        size: 12,
        font: helvetica,
        color: rgb(0.2, 0.2, 0.2)
      })
      yPos -= 24
    })

    // Footer
    coverPage.drawText('Generated by Vivah Visualization', {
      x: 50,
      y: 50,
      size: 10,
      font: helvetica,
      color: rgb(0.6, 0.6, 0.6)
    })

    // Page 2: Inventory List
    if (project.items.length > 0) {
      const inventoryPage = pdfDoc.addPage([612, 792])
      yPos = height - 60

      inventoryPage.drawText('Inventory List', {
        x: 50,
        y: yPos,
        size: 24,
        font: helveticaBold,
        color: rgb(0.1, 0.1, 0.1)
      })

      yPos -= 40

      // Group items by category
      const itemsByCategory = new Map<string, typeof project.items>()
      project.items.forEach(item => {
        const category = item.furnitureItem.category
        if (!itemsByCategory.has(category)) {
          itemsByCategory.set(category, [])
        }
        itemsByCategory.get(category)!.push(item)
      })

      // List by category
      itemsByCategory.forEach((items, category) => {
        // Category header
        inventoryPage.drawText(category, {
          x: 50,
          y: yPos,
          size: 14,
          font: helveticaBold,
          color: rgb(0.2, 0.2, 0.2)
        })
        yPos -= 20

        // Count items by type
        const countByType = new Map<string, number>()
        items.forEach(item => {
          const name = item.furnitureItem.name
          countByType.set(name, (countByType.get(name) || 0) + 1)
        })

        countByType.forEach((count, name) => {
          inventoryPage.drawText(`  â€¢ ${name}: ${count}`, {
            x: 50,
            y: yPos,
            size: 11,
            font: helvetica,
            color: rgb(0.3, 0.3, 0.3)
          })
          yPos -= 16

          // Add new page if needed
          if (yPos < 60) {
            const newPage = pdfDoc.addPage([612, 792])
            yPos = height - 60
          }
        })

        yPos -= 10
      })

      // Summary
      yPos -= 20
      inventoryPage.drawText(`Total Items: ${project.items.length}`, {
        x: 50,
        y: yPos,
        size: 12,
        font: helveticaBold,
        color: rgb(0.1, 0.1, 0.1)
      })
    }

    // Page 3: Notes (placeholder for future 3D renders)
    const notesPage = pdfDoc.addPage([612, 792])
    notesPage.drawText('Project Notes', {
      x: 50,
      y: height - 60,
      size: 24,
      font: helveticaBold,
      color: rgb(0.1, 0.1, 0.1)
    })

    if (project.description) {
      notesPage.drawText(project.description, {
        x: 50,
        y: height - 100,
        size: 12,
        font: helvetica,
        color: rgb(0.3, 0.3, 0.3),
        maxWidth: 500
      })
    } else {
      notesPage.drawText('No additional notes.', {
        x: 50,
        y: height - 100,
        size: 12,
        font: helvetica,
        color: rgb(0.5, 0.5, 0.5)
      })
    }

    const pdfBytes = await pdfDoc.save()
    return Buffer.from(pdfBytes)
  }

  // Export to image using Puppeteer
  async exportToImage(
    projectId: string,
    options: ExportImageOptions = {}
  ): Promise<Buffer> {
    const {
      width = 1920,
      height = 1080,
      format = 'png',
      quality = 90
    } = options

    // Launch headless browser
    const browser = await puppeteer.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu'
      ]
    })

    try {
      const page = await browser.newPage()
      await page.setViewport({ width, height })

      // Navigate to project viewer
      const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
      await page.goto(
        `${baseUrl}/projects/${projectId}/edit?export=true`,
        {
          waitUntil: 'networkidle0',
          timeout: 30000
        }
      )

      // Wait for canvas to load
      await page.waitForSelector('canvas', { timeout: 10000 })

      // Additional wait for 3D scene to fully render
      await new Promise(resolve => setTimeout(resolve, 2000))

      // Take screenshot
      const screenshot = await page.screenshot({
        type: format,
        quality: format === 'jpeg' ? quality : undefined,
        fullPage: false
      })

      return screenshot as Buffer
    } finally {
      await browser.close()
    }
  }

  // Export scene data as GLB
  async exportToGLB(projectId: string): Promise<Buffer> {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: {
        items: {
          include: { furnitureItem: true }
        }
      }
    })

    if (!project) throw new Error('Project not found')

    // For now, return a placeholder GLB
    // In production, this would:
    // 1. Reconstruct the Three.js scene server-side
    // 2. Use GLTFExporter to export to GLB format
    // This requires a Node.js 3D rendering solution like node-canvas + headless-gl

    const sceneData = project.sceneData as any

    // Create a minimal GLTF JSON structure
    const gltf = {
      asset: {
        version: '2.0',
        generator: 'Vivah Visualization Export'
      },
      scene: 0,
      scenes: [{
        name: project.name,
        nodes: [0]
      }],
      nodes: [{
        name: 'Root',
        children: project.items.map((_, i) => i + 1)
      }],
      // Add basic node data for each item
      ...project.items.reduce((acc, item, i) => {
        const position = item.position as { x: number; y: number; z: number }
        const rotation = item.rotation as { x: number; y: number; z: number }
        const scale = item.scale as { x: number; y: number; z: number }

        acc.nodes.push({
          name: item.furnitureItem.name,
          translation: [position.x, position.y, position.z],
          rotation: [rotation.x, rotation.y, rotation.z, 1], // Quaternion
          scale: [scale.x, scale.y, scale.z]
        })

        return acc
      }, { nodes: [] as any[] })
    }

    // Convert to binary GLB format
    const jsonString = JSON.stringify(gltf)
    const jsonBuffer = Buffer.from(jsonString)

    // GLB header
    const header = Buffer.alloc(12)
    header.writeUInt32LE(0x46546C67, 0) // glTF magic
    header.writeUInt32LE(2, 4) // Version 2
    header.writeUInt32LE(12 + 8 + jsonBuffer.length, 8) // Total length

    // JSON chunk header
    const chunkHeader = Buffer.alloc(8)
    chunkHeader.writeUInt32LE(jsonBuffer.length, 0)
    chunkHeader.writeUInt32LE(0x4E4F534A, 4) // JSON chunk type

    return Buffer.concat([header, chunkHeader, jsonBuffer])
  }

  // Create shareable link
  async createShareLink(
    projectId: string,
    options: ShareLinkOptions = {}
  ): Promise<string> {
    const {
      canEdit = false,
      canComment = true,
      canExport = false,
      password,
      expiresIn
    } = options

    const shareLink = await prisma.shareLink.create({
      data: {
        projectId,
        canEdit,
        canComment,
        canExport,
        password: password ? await this.hashPassword(password) : null,
        expiresAt: expiresIn
          ? new Date(Date.now() + expiresIn * 60 * 60 * 1000)
          : null
      }
    })

    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
    return `${baseUrl}/shared/${shareLink.token}`
  }

  // Verify share link access
  async verifyShareLink(token: string, password?: string): Promise<{
    valid: boolean
    projectId?: string
    permissions?: {
      canEdit: boolean
      canComment: boolean
      canExport: boolean
    }
    error?: string
  }> {
    const shareLink = await prisma.shareLink.findUnique({
      where: { token }
    })

    if (!shareLink) {
      return { valid: false, error: 'Share link not found' }
    }

    // Check expiration
    if (shareLink.expiresAt && shareLink.expiresAt < new Date()) {
      return { valid: false, error: 'Share link has expired' }
    }

    // Check max views
    if (shareLink.maxViews && shareLink.currentViews >= shareLink.maxViews) {
      return { valid: false, error: 'Share link view limit reached' }
    }

    // Check password
    if (shareLink.password) {
      if (!password) {
        return { valid: false, error: 'Password required' }
      }
      const isValid = await this.verifyPassword(password, shareLink.password)
      if (!isValid) {
        return { valid: false, error: 'Invalid password' }
      }
    }

    // Update view count
    await prisma.shareLink.update({
      where: { token },
      data: {
        currentViews: { increment: 1 },
        lastViewedAt: new Date()
      }
    })

    return {
      valid: true,
      projectId: shareLink.projectId,
      permissions: {
        canEdit: shareLink.canEdit,
        canComment: shareLink.canComment,
        canExport: shareLink.canExport
      }
    }
  }

  // Simple password hashing (use bcrypt in production)
  private async hashPassword(password: string): Promise<string> {
    const bcrypt = await import('bcryptjs')
    return bcrypt.hash(password, 10)
  }

  private async verifyPassword(password: string, hash: string): Promise<boolean> {
    const bcrypt = await import('bcryptjs')
    return bcrypt.compare(password, hash)
  }
}

// Export singleton instance
export const exportService = new ExportService()
